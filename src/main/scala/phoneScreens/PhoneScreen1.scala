package phoneScreens

import scala.collection.mutable
import scala.collection.SortedSet
import scala.annotation.tailrec

object PhoneScreen1 {

  /*
    Given: A global timestamp service that generates monotonically increasing timestamps (64 bit integers).

    A set of services that talk to the global timestamp service whenever something interesting happens and writes the timestamp to a sequential log.

    The timestamp log for a service can be accessed with the following interface

      make_interface(serviceName: String): TimestampIterator

    interface TimestampIterator {
      hasNext: Boolean
      next: Long
    }

    Given a width W and a set of service names find all the timestamps S such that for every Ti belonging to S
    Ti was generated by at least one service in the input list
    Closed interval [Ti, Ti+W] contains at least one timestamp generated by every service in the input list.

    W = 5
    S1: 1, 7, 100
    S2: 2, 12

    [1,6] has 1 from S1 and 2 from S2. - You choose 1

    [100, 105] - No representative from S2 - Reject it

    choose 1, 2, 7
    reject 12, 100

    S1: 1,.., 100
    S2: 101
  */

  implicit object LongIteratorOrdering extends Ordering[(Long, Iterator[Long])] {
    def compare(a:(Long, Iterator[Long]), b:(Long, Iterator[Long])) = {
      (a, b) match {
        case ((aVal, _), (bVal, _)) => -(aVal compare bVal)
      }
    }
  }

  // iterative solution
  def findTimes1(w: Long, services: Set[String]): Seq[Long] = {
    val serviceHeap = new mutable.PriorityQueue[(Long, Iterator[Long])]()

    var maxTime = 0L
    var terminate: Boolean = false
    for {
      service <- services
      if !terminate
    } {
      val it = make_interface(service)
      if (!it.hasNext) {
        terminate = true
      } else {
        val next = it.next()
        serviceHeap.enqueue((next, it))
        maxTime = Math.max(maxTime, next)
      }
    }

    var result: Seq[Long] = IndexedSeq.empty
    while (!terminate) {
      var (time, it) = serviceHeap.dequeue()

      if (time + w >= maxTime) {
        result = result :+ time
      }
      if (it.hasNext) {
        val next = it.next()
        maxTime = Math.max(maxTime, next)
        serviceHeap.enqueue((next, it))
      } else {
        terminate = true
      }
    }
    result
  }

  // Recursive solution
  def findTimes2(w: Long, services: Set[String]): Seq[Long] = {
    val serviceIterators = services.map(make_interface(_))

    if (serviceIterators.exists(!_.hasNext)) {
      Seq.empty
    } else {
      val nextAndServiceIterators = for {
        iterator <- serviceIterators.toSeq
      } yield {
        (iterator.next(), iterator)
      }
      val serviceIteratorsQueue = mutable.PriorityQueue(nextAndServiceIterators: _*)
      val maxNextTime = serviceIteratorsQueue.map { case (next, _) => next }.max
      findTimes2_0(w, serviceIteratorsQueue, maxNextTime, Seq.empty)
    }
  }

  @tailrec
  def findTimes2_0(w: Long, serviceIteratorsQueue: mutable.PriorityQueue[(Long, Iterator[Long])], maxNextTime: Long, acc: Seq[Long]): Seq[Long] = {
    val (minNextTime, it) = serviceIteratorsQueue.dequeue()

    // include the min timestamp if all other timestamps fall in range, otherwise skip it
    val newAcc = if (minNextTime + w >= maxNextTime) {
      acc :+ minNextTime
    } else {
      acc
    }

    if (!it.hasNext) {
      newAcc
    } else {
      val next = it.next()
      serviceIteratorsQueue.enqueue((next, it))
      findTimes2_0(w, serviceIteratorsQueue, maxNextTime max next, newAcc)
    }
  }

  var serviceTimestamps: Map[String, Seq[Long]] = Map.empty

  /**
   * Let's assume this always returns something valid or we'd just propagate the error.
   */
  def make_interface(string: String): Iterator[Long] = {
    serviceTimestamps(string).iterator
  }
}